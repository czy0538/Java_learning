java语言程序设计

## 0.基本结构

### 0.1 基础结构

```java
import java.util.Scanner;//import java.util.*;倒入所有类

public class Main//至少一个类，首字母大写
{
	public static void main(String[] args)//主方法
    {
        System.out.println("Hello world");//大小写敏感，有分号
    }
}
```

### 0.1.1 输入与输出

- System.out表示标准输出设备

- System.in表示标准输入设备

- 从控制台读入需要创建Scanner类的对象

  ```java
  Scanner input=new Scanner(system.in);//把Scanner对象的引用赋给变量input
  ```

- print不换行，println自动换行

- 数字转为字符串的简单办法 1+"" 

### 0.1.2 变量与常量

- 变量基本同c++

- 常量 用final

  不使用static修饰：如果建立常量时直接赋一个固定值，那么这个常量的值是固定不变的，即多个对象中的值也是相同的。如果建立常量时是采用函数或对象，那么每次建立对象时给其常量的初始化值就有可能不同。所以，只使用final的Java常量定义并不是恒定的。
  使用static修饰：在创建对象之前就会为这个变量在内存中创建一个存储空间，以后创建对象如果需要用到这个静态变量，那么就会共享这一个变量的存储空间。

- 命名习惯：
  - 小写字母明明变量和方法
  - 类名首字母大写
  - 常量所有字母大写

### 0.1.3 数据类型

基本同c++

- byte为整数的最小类型-128~127
- 字面量long型加l，否则被认为int
- 科学计数法为E
- bool型为boolean，true和false均为小写

### 0.1.4 String类型

***String对象是不可改变的，一旦创建，内容不能再改变***

#### 0.1.4.0 字符串创建

- String newString =new String(s);
- var newString= new String(s);
- String newString=" s";
- String message=new String(charArray);

#### 0.1.4.1 简单方法

| 实例方法                             | 描述                                        |
| ------------------------------------ | ------------------------------------------- |
| .length()                            | 返回长度                                    |
| .charAt(index)                       | 返回指定字符位置                            |
| .concat(s2)                          | 返回连接后字符串                            |
| .trim()                              | 返回去掉两边空格的字符串                    |
| .equal(s2)                           | 若相同返回True                              |
| .compareTo(s2)                       | 返回整数，一个字符串是否大于小于等于s2      |
| .contains(s2)                        | s2是不是该字符串子串                        |
| .startsWith(string)/endsWith(string) | 是否以特定字符串开头/结尾                   |
| .substring(begin,end)                | 取从begin到end-1的子串                      |
| .indexOf(s,from)                     | 返回第一次出现s下标，从from开始，没有返回-1 |
| .lastIndexOf(s,from)                 | 返回最后出现s下标，从from开始，没有返回-1   |
| Type.parseType(string)               | 字符串转type类型数字                        |

```java
var str=new String(" Hello,Java "):  Hello,Java
str.length() :12
str.charAt(0) :
str.toUpperCase() : HELLO,JAVA
str.toLowerCase() : hello,java
str.trim() :Hello,Java
str.concat("hehe") : Hello,Java hehe
//加号也可以连接字符串,会对第一个数字进行转换成字符串类型
1+2= +1+2 12
1+2= +(1+2) 3
```



- 相等运算符只能检测是否指向同一个对象，不会告知内容是否相等
- 数字转字符串 String s=124+""

#### 0.1.4.2 字符串读入

input.nextLine()

不要再nextByte等后使用nextLine

#### 0.1.4.3 字符串的替换和分隔

str.replace(oldchar,newchar) 替换所有匹配的字符，返回新的字符串

str.replaceFirst(oldchar,newchar)替换第一个匹配的子字符**串**，返回新的字符串

str.replaceAll(oldchar,newchar)替换所有匹配的子字符**串**，返回新的字符串

str.split(分隔符)返回字符数组，包含被分隔符分割的子字符串集

#### 0.1.4.4 依照模式匹配、替换和分割

正则表达式regex

```java
        var str1 = new String("Java is fun");
        String s1 = "Java";
        System.out.println(str1.matches("Java"));
        System.out.println(str1.equals("Java"));
        System.out.println(str1.matches("Java.*"));
        System.out.println(s1.matches("Java"));
        System.out.println(s1.equals("Java"));
//输出:
false
false
true
true
true
```



#### 0.1.4.5字符串与数组转换

```java
		char [] chars="java".toCharArray();
        for(var i:chars)
        {
            System.out.println(i);
        }
        String str1 =new String(chars);
        System.out.println(str1);

        String str2= String.valueOf(chars);
        System.out.println(str2);
//out
j
a
v
a
java
java
```

#### 0.1.4.6 字符和数值转与字符串互转

```java
		var s = new String("3.14");
        double pi = Double.parseDouble(s);
        System.out.println((pi));

        var str = String.valueOf(pi);
        System.out.println(str)
```

#### 0.1.4.7格式化字符串

静态format方法，类似printf

```java
System.out.println("begin"+String.format("%7.2f%6d%-4s", 23.233, 99, "YYX")+"end");
begin  23.23    99YYX end
```



### 0.2方法（函数）

#### 0.2.1 基本格式

```java
修饰符 返回值类型 方法名（形参列表）
{
方法体
}
```

#### 0.2.2 重载方法

函数名相同，签名不同（形参类型），不能基于不同的修饰符或者返回值类型

java的普通变量不支持传引用

### 0.3lambda表达式（类似匿名函数）

lambda表达式就是一个代码块，以及必须传入代码的变量规范。

标准形式：

```java
(参数)-> 表达式，如果无法放在一个表达式中需要加大括号，并包含显示return语句
即使lambda表达式没有参数，仍然需要提供空括号
无需指定lambda表达式的返回值类型

public class LambdaTest
{
   public static void main(String[] args)
   {
      String[] planets = new String[] { "Mercury", "Venus", "Earth", "Mars", 
            "Jupiter", "Saturn", "Uranus", "Neptune" };
      System.out.println(Arrays.toString(planets));
      System.out.println("Sorted in dictionary order:");
      Arrays.sort(planets);
      System.out.println(Arrays.toString(planets));
      System.out.println("Sorted by length:");
      Arrays.sort(planets, (first, second) -> first.length() - second.length());
      System.out.println(Arrays.toString(planets));//传代码块
            
      Timer t = new Timer(1000, event ->
         System.out.println("The time is " + new Date()));//传代码块
      t.start();   
         
      // keep program running until user selects "Ok"
      JOptionPane.showMessageDialog(null, "Quit program?");
      System.exit(0);         
   }
}

```
- 可以作为函数式接口，但是不能作为函数类型。
- 不能把lambda表达式赋给类型为Object的变量
- lambda表达式即为java的闭包
- ***只能引用值不会改变的变量！***不能引用在外部有可能改变的量。即
- **lambda**表达式中补货的变量必须实际上是最终变量，即初始化后就不会为它赋新值

#### 0.3.2 方法引用

```java
Timer t=new Timer(1000,event->System.out.printlen(event));
Timer t=new Timer(1000,System.out::println(event));
用::操作符分割方法名与对象或者类名
object::instanceMethod
Class::staticMethod
方法引用等价于提供方法参数的lambda表达式(Math::pow(x,y)<=>(x,y)->Math.pow(x,y))
    
Class::instanceMethod
第一个参数会成为方法的目标(String::compareToIgnoreCase<=>(x,y)->x.compareToIgnoreCase(y))
```

- 可以在方法引用中使用this，super参数



### 0.4 使用命令行

- 编译java程序 javac filename.java

- 运行java程序 java filename
- 重定向与管道
  - 把应该出现在控制台中的输出放到data.txt中 java filename > data.txt
  - 从data.txt中读取应该从控制台中读入的内容 filename < data.txt
  - java file1 | java file2 file1的输出作为file2的输入

##　１数组

### 1.1 一维数组

#### 1.1.1 声明数组变量（创建一个引用）

elementType[] arrayRefVar;

也支持c++风格的声明方式

#### 1.1.2 创建数组

  arrayRefVar= new elementType[arraySize];

arraySize可以是变量

#### 1.1.3 数组初始化

  elementType [] arrayRefVar={value0,value1,...};

对象数组需要逐个初始化

#### 1.1.4 foreach循环

  for(elementType element:arrayRefVar)

  无法改变，只能访问



打印数组全部内容：Arrays.toString(arrayName);

#### 1.1.5 数组复制

  - 不可以直接用等于号，那样赋值的是引用
  - 1. 使用循环语句逐个复制
    2. 使用System类中的静态方法arraycopy
    3. 使用clone方法

```java
int[] sourceArray= {2,3,1,5,10};
int[] targetArray= new int[sourveArray.length]
//使用循环语句逐个复制
for(int i = 0; i<sourceArray.length;++i)
{
    targetArray[i]=sourceArray[i];
}
//arraycopy
System.arraycopy(sourceArray,srcPos,targetArray,tarPos,length)
```

#### 1.1.6 数组与方法

- 当将一个数组传递给方法时，数组的引用被传给方法

- 数组在java中是对象，jvm将对象储存在heap中，用于动态内存分配

- public static void name (int[] number)

- 当从方法中返回一个数组时，返回的是数组的引用

  ```java
  	public static int[] reverse(int[] in)
  	{
  		int[] array = new int[in.length];
  		for (int i = 0, j=in.length-1; i < in.length; ++i,--j)
  		{
  
  				array[j] = in[i];
  
  		}
  		return array;
  	}
  ```

  

- 可变参数列表，当作一个数组对待

  ```java
  public static int max(int... e)//参数类型 ... 名字
  	{
  		int max = e[0];
  		for (int i = 0; i < e.length; i++)
  		{
  			if (max < e[i])
  			{
  				max = e[i];
  			}
  		}
  		return max;
  	}
  ```

  



## 2.对象与类

可以把两个类放在一个文件中，文件中只能有一个类是public。public类必须与文件同名，非public类只能在自己的包里访问

### 2.1 定义类

```java
class Circle
{
	final double pi=3.1415926;
	double r;
	Circle()
	{
		Scanner input=new Scanner(System.in);//创建对象方法
		System.out.print("请输入半径r：");
		r=input.nextDouble();
	}
	Circle(double rr)
	{
		r=rr;
	}
	double area()
	{
		return Math.pow(r,2)*pi;
	}
}
```

大部分与cpp相同，只是找不同的地方。

- 引用类型默认值为null

- Java没有给方法中的局部变量赋默认值

  ```java
  public class Main()
  {
      public static String main(String args)
      {
         	A a=new A();
          int x;
          System.out.println(a.x);//x=0
          System.out.println(x);//error
      }
  }
  class A
  {
      int x;
  }
  ```



### 2.2 可见性修饰符

- public修饰符：用在类，方法，数据域前，表示他们可以被任何一个其他类访问。
- 如果没有，认为是friendly，只可被同一个包中任何一个类访问。
- private修饰符：只能在自己的类中被访问，同一个类的不同对象私有成员可以互访
- package packageName;
- 保护数据：数据设定为私有，然后通过get访问，set修改
- 给方法传递一个对象，是传递的对象的引用
- ![1568947162860](D:\A personal date\GitHub\Java_learning\1568947162860.png)

### 2.3 this引用

this引用对象自身，常用在引用隐藏数据域，调用构造方法。

#### 2.3.1 引用隐藏数据域

如在set方法中，使用数据名作为参数名。

```java
class A
{
	int i;
	void setI(int i)
	{
		this.i=i;//局部变量i会掩盖类变量i，所以需要显式的this
	}
}
```

#### 2.3.2 使用this构造方法

```java
public class Circle
{
    private double radius;
   
    public Circle(double r)
    {
        this.r=r;
    }
    public Circle()
    {
        this.Circle(1.0);//调用上面的构造方法
    }
}
```

### 2.4 包

#### 2.4.1 管理架构（IDEA）

project->module->package->class

用文件夹来管理包，一个文件夹下的所有文件时一个包，包名就是那个文件夹的名字

有点类似于include

包里面的点代表一个文件层次

#### 2.4.2 使用

```java
import display.*;//导入display下所有包
import display.Display
```

### 2.5 static和final（类XX）

- Java 中被 static 修饰的成员称为静态成员或类成员。它属于整个类所有，而不是某个对象所有，即被类的所有对象所共享。静态成员可以使用类名直接访问，也可以使用对象名进行访问
- 被 static 修饰的方法是静态方法，静态方法不依赖于对象，不需要将类实例化便可以调用，由于不实例化也可以调用，所以不能有 this，也不能访问非静态成员变量和非静态方法。但是非静态成员变量和非静态方法可以访问静态方法

`final`关键字可以修饰类、方法、属性和变量

1. final 修饰类，则该类不允许被继承，为最终类
2. final 修饰方法，则该方法不允许被覆盖（重写）
3. final 修饰属性：则该类的属性不会进行隐式的初始化（类的初始化属性必须有值）或在构造方法中赋值（但只能选其一）
4. final 修饰变量，则该变量的值只能赋一次值，即常量

### 2.6 继承

- class A extends B  A继承B
- 父类private数据域无法被子类访问
- 是一种is-a的关系

#### 2.6.1 super关键字

- 调用 父类类的构造方法: super(argumenets)，这个调用必须是构造方法的第一条语句

- 在任何情况下，构造一个类的实例时，将会沿着继承链的所有父类的构造方法。
- 调用父类的方法 super.方法名（参数）；

#### 2.6.2 方法重写与重载

- 重写需要在子类中使用和父类一样的签名以及一样的返回值类型
- 仅当实例方法可以访问时才能被覆盖
- 静态方法不能被覆盖，如果定义的静态方法在子类中被重新定义在父类中将被隐藏。
- 重写标注@Override

![img](D:\A personal date\GitHub\Java_learning\20171102-1.jpg)



#### 2.6.4Object类

事实上，java所有的类都继承自Object类

toString，返回类名@地址

equals，测试两个对象是否相等

getClass 返回对象的类

我们一般需要重写to String方法和equals方法

```java
//接口和重写toString equals的模版
/*重写equals应该满足：
自反性，对称性，传递性，一致性，非空性*/
public interface Datable
{
    int month();
    int day();
    int year();
}

public class Date implements Datable
{
    private final int month;
    private final int day;
    private final int year;

    public Date(int month, int day, int year)
    {
        this.month = month;
        this.day = day;
        this.year = year;
    }

    @Override
    public int month()
    {
        return month;
    }

    @Override
    public int day()
    {
        return day;
    }

    @Override
    public int year()
    {
        return year;
    }

    @Override
    public String toString()
    {
        return month() + "/" + day() + "/" + year();
    }

    @Override
    public boolean equals(Object obj)
    {
        if (this == obj)
        {
            return true;
        }
        if (obj == null)
        {
            return false;
        }
        if (this.getClass() != obj.getClass())
        {
            return false;
        }
        Date that = (Date) obj;
        if (this.day != that.day)
        {
            return false;
        }
        if (this.month != that.month)
        {
            return false;
        }
        if (this.year != that.year)
        {
            return false;
        }
        return true;
    }
}

```



### 2.7多态

- 任何使用父类对象的地方都可以使用子类的对象。

- 即多态意味着父类型的变量可以引用子类型的对象。

- 调用方法时由子类依次向父类查找。（动态绑定)
- instanceof运算符
  由于类的多态性，类的变量既可以指向本类实例，又可以指向其子类的实例。在程序中，有时需要判明某个引用到底指向哪个实例，这可以通过instanceof运算符来实现。 a instanceof ClassName
- Java允许使用对象之父类类型的一个变量指示该对象，称为转换对象(casting)。



### 2.8 抽象类

定义了方法却没有定义具体如何实现的类称为抽象类。

- 抽象方法：

  ```java
  abstract type name();
  ```

- 包含抽象方法的类本身必须被声明为抽象的

- 抽象类不能被实例化。



### 2.9接口类型

```JAVA
interface 接口名称[extends 父接口名]{
          //方法原型或静态变量
}
//接口的实现
[类修饰符] class 类名 implements 接口名称 {
          //接口实现
          //其它内容
}
```

- 接口中的方法自动地属于public
- 接口不能含有实例域，可以含有简单方法
- 实现接口时，必须把方法声明为public
- double ... x//可以传任意数量的double，应用的时候相当于数组

### 2.10 泛型（即模版）

如果一个类或接口包含了一个或多个类型变量，则称该类或接口为范型类或范型接口。

```java
[修饰符] [static] [final] [abstract] class 类名<类型参数表> 
                               [extends 父类名] [implements 接口名]{
         类体;
}

[修饰符] interface 接口名称<类型参数表>  [extends 父接口名列表] {
         接口体;
}

```

创建泛型数组是不允许的，需要使用类型转换 

Item [] a;

a=(Item[]) new Object[cap];



#### 2.11内部类

- 内部类：也称为嵌套类，是指在一个类或接口内部声明的类。内部类包括：成员类、局部类和匿名类。
- 内部接口：也称为嵌套接口，是在一个类或接口的内部声明一个接口。由于接口并不实现任何行为，所以，嵌套接口都是成员接口。
- 封装类/接口：包含内部类或内部接口的类和接口分别称为封装类和封装接口。

##### 2.11.1非静态成员类

- 成员类是在封装类或封装接口中作为成员声明的类。
- 成员类包含非静态成员类和静态成员类。
- 非静态成员类具有如下特征：
  非静态成员类中不能定义静态变量和方法。
  非静态成员类可以访问封装类的所有成员。
  在非静态成员类中访问封装类的成员时，若封装类的成员与成员类的成员不重名，则可以直接用成员名进行访问；若封装类与成员类的成员的成员重名，访问封装类实例成员的语法为：**封装类类名.this.封装类实例成员名;**

- 在封装类之外创建非静态成员类实例时，需要先创建封装类的实例，然后创建非静态成员类的实例。

##### 2.11.2静态成员类

- 静态成员类具有如下特征：
- 静态成员类中既可以定义静态成员，也可以定义非静态成员。
- **静态成员类中能直接访问封装类的所有静态成员，但不能直接访问封装类的非静态成员。**
- 在静态成员类中访问封装类的成员时，若封装类的成员与成员类的成员不重名，则可以直接用成员名进行访问；若封装类与成员类的成员的成员重名，访问封装类静态成员的语法为：封装类类名.封装类静态实例成员名;

##### 2.11.3局部类

- 局部类是在**封装类的方法中定义的内部类**，与局部变量类似，其作用域是定义它的代码块。
- 局部类的典型用法是与接口相配合，用局部类来实现接口，并在方法中返回接口类型。
- 局部类具有如下特征：
  - 局部类的类名不能与其封装类重名。
  - 局部类可以是abstract和final型，访问修饰符只能是缺省的，**不能是public、private或protected。**
  - 局部类中不允许包括静态成员(变量和方法)。
- 在局部类中只能访问它所在方法中的final型变量，不能访问非final型的变量。
- 局部类只在定义它的代码段中可见，只能在封装类内部使用，在封装类之外是不可见的，不能在封装类之外创建局部类的实例。
- 在局部类中可以访问封装类的成员，如果局部类成员与封装类成员不重名，可以直接用成员名进行访问；重名访问方法同上

```java
package test;

public interface OuterInterface
{
    public int signfunc(int outerValue);
}

public class OuterClass
{
    public OuterInterface getInterface()
    {
        class LocalClass implements OuterInterface
        {
            public int signfunc(int value)
            {
                if (value < 0)
                {
                    return -1;
                }
                else if (value == 0)
                {
                    return 0;
                }
                else return 1;
            }
        }
        return new LocalClass();
    }
    public static void main(String[] args)
    {
        OuterClass oc=new OuterClass();
        OuterInterface oi=oc.getInterface();
        StdOut.println(oi.signfunc(10));
    }
}

```

#####　2.11.4　匿名类

new 匿名类类名或接口名(){
        类体;
}

匿名类具有如下特征：

- 匿名类必须是一个具体的对象，不允许是abstract的，也不可以是static。
- 匿名类的类体必须将其继承或实现的内容具体化(与普通类没有差别)。
- 匿名类本身没有名字，所以没有构造方法，只能用super关键字调用其父类的构造方法。
- 匿名类只能是final型的，其中包括的所有变量和方法都是final型的。

##### 2.11.5 成员接口

- 成员接口是指在封装类或封装接口中声明的接口。
- 当一个接口被嵌套在一个类中时，该接口修饰符可以是public、private和缺省的，private接口只能在封装类的内部实现和使用。
- 当一个接口被嵌套在一个接口中时，成员接口自动拥有封装接口访问范围，可以在外部加以实现。

## 3.对象容器

### 3.0 基本数据类型作为对象

- 除了Integer和Character以外，其他都是首字母大写。
- 可以用基本数据类型值或者表示字符的字符串来构造包装类
- 包装类的实例无法改变，即创建对象后对象的内部值无法改变
- 每个都有doubleValue(),floatValue(),等方法，返回double，float等值
- 有compareTo( )方法，大于返回1，等于0，小于-1
- valueOf(string s)方法将对象初始为字符串值
- Integer.parseInt("num",进制) 将制定进制数值字符串转为10进制
- String.format("%x",26)将10进制转为16进制、
- BigInteger 和 BigDecimal类可以表示任意大小和京都的整数或十进制数
  - 通过add，subtract,multiple,divide,remainder，进行算术运算，compareTo比较

### 3.1StringBuilder and StringBuffer

- 均可以添加、插入或者追加新的内容

- StringBuffer修改缓冲区的方法是同步的，多任务并发访问使用

- 由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。

- ## StringBuffer 方法

  以下是 StringBuffer 类支持的主要方法：

  | 序号 | 方法描述                                                     |
  | :--- | :----------------------------------------------------------- |
  | 1    | public StringBuffer append(String s) 将指定的字符串追加到此字符序列。 |
  | 2    | public StringBuffer reverse()  将此字符序列用其反转形式取代。 |
  | 3    | public delete(int start, int end) 移除此序列的子字符串中的字符。 |
  | 4    | public insert(int offset, int i) 将 `int` 参数的字符串表示形式插入此序列中。 |
  | 5    | replace(int start, int end, String str) 使用给定 `String` 中的字符替换此序列的子字符串中的字符。 |

  下面的列表里的方法和 String 类的方法类似：

  | 序号 | 方法描述                                                     |
  | :--- | :----------------------------------------------------------- |
  | 1    | int capacity() 返回当前容量。                                |
  | 2    | char charAt(int index) 返回此序列中指定索引处的 `char` 值。  |
  | 3    | void ensureCapacity(int minimumCapacity) 确保容量至少等于指定的最小值。 |
  | 4    | void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) 将字符从此序列复制到目标字符数组 `dst`。 |
  | 5    | int indexOf(String str) 返回第一次出现的指定子字符串在该字符串中的索引。 |
  | 6    | int indexOf(String str, int fromIndex) 从指定的索引处开始，返回第一次出现的指定子字符串在该字符串中的索引。 |
  | 7    | int lastIndexOf(String str) 返回最右边出现的指定子字符串在此字符串中的索引。 |
  | 8    | int lastIndexOf(String str, int fromIndex) 返回 String 对象中子字符串最后出现的位置。 |
  | 9    | int length()  返回长度（字符数）。                           |
  | 10   | void setCharAt(int index, char ch) 将给定索引处的字符设置为 `ch`。 |
  | 11   | void setLength(int newLength) 设置字符序列的长度。           |
  | 12   | CharSequence subSequence(int start, int end) 返回一个新的字符序列，该字符序列是此序列的子序列。 |
  | 13   | String substring(int start) 返回一个新的 `String`，它包含此字符序列当前所包含的字符子序列。 |
  | 14   | String substring(int start, int end) 返回一个新的 `String`，它包含此序列当前所包含的字符子序列。 |
  | 15   | String toString() 返回此序列中数据的字符串表示形式。         |



### 3.2ArrayList

插入的类型不能是基本类型，必须是泛型。

```java
ArrayList<Object> arrayList = new ArrayList<>();
		//1.大小
		arrayList.size();
		//2.添加
		arrayList.add(new Object());
		//3.指定位置添加
		arrayList.add(0, new Object());
		//4.判断对象是否在容器内(引用判断) 返回 boolean 值
		arrayList.contains(new Object());
		//5.获取指定位置的对象(范围内)
		arrayList.get(index);
		//6.获取对象位置(有相同引用的对象 返回最前的下标，不能直接用【】)
		arrayList.indexOf(new Object());
		//7.删除指定下标的对象
		arrayList.remove(index);
		//8.删除指定对象(有相同引用删除 最前面的)
		arrayList.remove(new Object());
		//9.删除全部
		arrayList.clear();
		arrayList.removeAll(arrayList);
		//10.替换 指定下标的对象
		arrayList.set(index, new Object());
		//11.转换为指定泛型的数组
		Object []object = arrayList.toArray(new Object []{});
		//12.添加另一个容器的所有对象
		arrayList.addAll(new ArrayList());//添加到最后
		arrayList.addAll(index,new ArrayList());//在指定位置添加

```

### 3.3vector

允许不同类型的元素共存在一个Vector中、

Vector 类实现了一个动态数组。和 ArrayList 很相似，但是两者是不同的：

- Vector 是同步访问的。
- Vector 包含了许多传统的方法，这些方法不属于集合框架。

Vector 主要用在事先不知道数组的大小，或者只是需要一个可以改变大小的数组的情况。

| 1    | void add(int index, Object element)   在此向量的指定位置插入指定的元素。 |
| ---- | ------------------------------------------------------------ |
| 2    | boolean add(Object o)   将指定元素添加到此向量的末尾。       |
| 3    | boolean addAll(Collection c)  将指定 Collection 中的所有元素添加到此向量的末尾，按照指定 collection 的迭代器所返回的顺序添加这些元素。 |
| 4    | boolean addAll(int index, Collection c)  在指定位置将指定 Collection 中的所有元素插入到此向量中。 |
| 5    | void addElement(Object obj)   将指定的组件添加到此向量的末尾，将其大小增加 1。 |
| 7    | void clear()  从此向量中移除所有元素。                       |
| 8    | Object clone()  返回向量的一个副本。                         |
| 9    | boolean contains(Object elem)  如果此向量包含指定的元素，则返回 true。 |
| 10   | boolean containsAll(Collection c)  如果此向量包含指定 Collection 中的所有元素，则返回 true。 |
| 12   | Object elementAt(int index)  返回指定索引处的组件。          |
| 14   | void ensureCapacity(int minCapacity)  增加此向量的容量（如有必要），以确保其至少能够保存最小容量参数指定的组件数。 |
| 15   | boolean equals(Object o)  比较指定对象与此向量的相等性。     |
| 16   | Object firstElement()  返回此向量的第一个组件（位于索引 0) 处的项）。 |
| 17   | Object get(int index)  返回向量中指定位置的元素。            |
| 18   | int hashCode()  返回此向量的哈希码值。                       |
| 19   | int indexOf(Object elem)   返回此向量中第一次出现的指定元素的索引，如果此向量不包含该元素，则返回 -1。 |
| 20   | int indexOf(Object elem, int index)   返回此向量中第一次出现的指定元素的索引，从 index 处正向搜索，如果未找到该元素，则返回 -1。 |
| 21   | void insertElementAt(Object obj, int index)  将指定对象作为此向量中的组件插入到指定的 index 处。 |
| 22   | boolean isEmpty()  测试此向量是否不包含组件。                |
| 23   | Object lastElement()  返回此向量的最后一个组件。             |
| 24   | int lastIndexOf(Object elem)   返回此向量中最后一次出现的指定元素的索引；如果此向量不包含该元素，则返回 -1。 |
| 25   | int lastIndexOf(Object elem, int index)  返回此向量中最后一次出现的指定元素的索引，从 index 处逆向搜索，如果未找到该元素，则返回 -1。 |
| 26   | Object remove(int index)   移除此向量中指定位置的元素。      |
| 27   | boolean remove(Object o)  移除此向量中指定元素的第一个匹配项，如果向量不包含该元素，则元素保持不变。 |
| 28   | boolean removeAll(Collection c)  从此向量中移除包含在指定 Collection 中的所有元素。 |
| 29   | void removeAllElements()  从此向量中移除全部组件，并将其大小设置为零。 |
| 30   | boolean removeElement(Object obj)  从此向量中移除变量的第一个（索引最小的）匹配项。 |
| 31   | void removeElementAt(int index)  删除指定索引处的组件。      |
| 32   | protected void removeRange(int fromIndex, int toIndex) 从此 List 中移除其索引位于 fromIndex（包括）与 toIndex（不包括）之间的所有元素。 |
| 33   | boolean retainAll(Collection c)  在此向量中仅保留包含在指定 Collection 中的元素。 |
| 34   | Object set(int index, Object element)  用指定的元素替换此向量中指定位置处的元素。 |
| 35   | void setElementAt(Object obj, int index)  将此向量指定 index 处的组件设置为指定的对象。 |
| 36   | void setSize(int newSize)   设置此向量的大小。               |
| 37   | int size()   返回此向量中的组件数。                          |
| 38   | List subList(int fromIndex, int toIndex)  返回此 List 的部分视图，元素范围为从 fromIndex（包括）到 toIndex（不包括）。 |
| 39   | Object[] toArray()  返回一个数组，包含此向量中以恰当顺序存放的所有元素。 





### 3.4 迭代

- for-each就是一种迭代，等价于以下语句

  ```java
  Stack<string> collection=new Stack<String>();
  ...
  Iterator<String> i=collention.iterator();
  while(i.hasNext())
  {
      String s=i.next();
      System.out.println(s);
  }
  ```

  - 集合数据类型必须实现一个iterator()方法并且返回一个Iterator对象
  - Iterator类必须包含:hasnext()和next()方法

- Java已经留好了迭代的接口

  - 在类的声明中加入 implements Iterable<Item>
  - 然后添加一个iterator()方法并返回迭代器
  - 然后写一个迭代器嵌套类

  ```java
  import edu.princeton.cs.algs4.StdOut;
  
  import java.util.Iterator;
  
  public class Res<Item> implements Iterable<Item>
  {
      private Item[] a = (Item[]) new Object[1];
      private int N = 0;
  
      public boolean isEmpty()
      {
          return N == 0;
      }
  
      public int size()
      {
          return N;
      }
  
      public void push(Item item)
      {
          if (N == a.length)
          {
              resize(2 * a.length);
          }
          a[N++]=item;
      }
  
      public Item pop()
      {
          Item item = a[--N];
          a[N] = null;//调用GC机制防止出现孤儿
          if (N > 0 && N == a.length / 4)
          {
              resize(a.length / 2);
          }
          return item;
      }
  
      private void resize(int max)
      {
          Item[] temp = (Item[]) new Object[max];
          for (int i = 0; i < a.length; i++)
          {
              temp[i]=a[i];
          }
  
              a = temp;
      }
  
      @Override//重写迭代器
      public Iterator<Item> iterator()
      {
          return new ResIterator();
      }
  
      private class ResIterator implements Iterator<Item>
      {
          private int i = N;
  
          @Override
          public boolean hasNext()
          {
              return i > 0;
          }
  
          @Override
          public Item next()
          {
              return a[--i];
          }
  
          @Override
          public void remove()
          {
  
          }
  
      }
    
  }
  
  ```


### 3.5HashMap

- 创建：HashMap<String,Integer> hashMap = new HashMap<>();

- 添加：

  - hashMap.put("aa",1);添加元素时，如果key已经存在，则返回旧value，并将新的value存到该key中；如果key不存在，则返回null
  -  hashMap.putIfAbsent("aa",4);该方法首先会判断key是否存在，如果存在且value不为null，则不会覆盖原有的value，并返回原来的value；如果key不存在或者key的value为null，则会put进新值，并返回null。

- remove(key):删除成功(存在key)，返回被删除的key对应的value，否则返回null

- hashMap.get("cc");

- getOrDefault("aa",-1)*//key=aa不存在，所以返回默认value -1*

- 遍历：

```
 for (Integer integer : num.keySet())
 {    
 int key = (int) integer;    
 System.out.println("key:" + key);
 }
```



## 4.异常处理

运行时错误会作为异常抛出。

异常是一种对象，表示阻止正常进行程序执行的错误或者情况。

### 4.1 try-catch

```java
package app;

import java.util.Scanner;

public class App {
    public static int quotient(int num1,int num2) {
        if(num2==0)
        {
            throw new ArithmeticException("Divisor cannot be zero");//异常，调用catch块
        }
        return num1/num2;
    }
    public static void main(String[] args) throws Exception {
        System.out.println("Hello Java");
        var input = new Scanner(System.in);
        int num1=input.nextInt();
        int num2=input.nextInt();
        try {//正常情况执行的代码
            int result = quotient(num1,num2);
            System.out.println(result);
        } catch (ArithmeticException ex) {
            //异常情况执行的代码
            System.out.println("hehe");
        }
	//执行过catch后继续执行下面的语句
    }
}
```

### 4.2 异常类型

Throwable类是所有异常类的根类。

- 系统错误（system error）

  由Java虚拟机抛出，用Error类表示。描叙内部系统错误。很少发生。一旦发生，除了通知用语终止程序别的什么也做不了。

  | LinkageError        | 一个类对另一个类有依赖，但是在编译前者后后者进行了修改变得不兼容 |
  | ------------------- | ------------------------------------------------------------ |
  | VirtualMachineError | java虚拟机崩溃，或者运行所必须的资源已经耗尽                 |

- 异常（exception）

  描述的是由程序和外部环境所引起的错误，这些错误能被程序捕获和处理。

  | ClassNotFoundException | 试图使用一个不存在的类 |
  | ---------------------- | ---------------------- |
  | IOException            | 同输入输出相关的操作   |

- 运行时异常（runtime exception）

程序设计错误，如错误的类型转换，访问越界数组或者数值错误，通常由虚拟机抛出。

| ArithmeticException       | 一个整数除以0.浮点数运算不引起异常   |
| ------------------------- | ------------------------------------ |
| NullPointerException      | 试图通过一个null引用变量访问一个对象 |
| IndexOutOfBoundsException | 数组的下标超出范围                   |
| IllegalArgumentException  | 传递给方法的参数非法或者不合适       |



免检异常：RuntimeException、Error及其子类

必检异常：其他所有异常，编辑器会强制程序员检查并通过try-catch语句处理

### 4.3异常处理的更多知识

#### 4.3.1 声明异常

每个方法都必须声明它可能抛出的必检异常类型。

java不要求在方法总显示的声明Error和RuntimeException即免检异常。

方法要抛出的其他异常都必须在方法头中显式声明。

```java
public void myMethod() throws IOExceotion

public void myMethod() throws Exception1,Exception2,...,ExceptionN
```

如果方法没有在父类中声明异常，那么就不能在子类中对其进行继承来声明异常。



#### 4.3.2抛出异常

```java
throw new 异常类("异常描述");
```

#### 4.3.3捕获异常

```java
try{
    staments;
}
catch(Exception1 ex1)
{
    handle for exception1;
}
catch(Exception1 ex2)
{
    handle for exception2;
}

catch(Ex1|Ex2)/]同样的代码处理多个异常
```

若try块的过程中没有出现异常，跳过catch语句





## 5Swing

### 5.1main函数

```java
public static void main(String[] args) {
    //我也不知道是啥东西，但是写上就不会出问题了
        EventQueue.invokeLater(() -> {
            //所有的框架类在这里新建
            CalculatorFrame frame=new CalculatorFrame();
        });
    }
```

### 5.2 JFrame

- 顶层容器

  ```java	
  public class Frame extends JFrame
  {
  	//定义框架的默认像素
  	private final int screenHeight；
      private final int screenWidth；
  	public Frame(	)
  	{
  	//可选，可以获得当前屏幕的分辨率信息
  	Toolkit kit = Toolkit.getDefaultToolkit();
      Dimension screenSize = kit.getScreenSize();
      screenHeight = screenSize.height;
    	screenWidth = screenSize.width;
      //设置默认的大小
      setSize(screenWidth / 4, screenHeight / 2);
      //或者使用自适应大小
      pack();
      //设置位置是否随平台改变
      setLocationByPlatform(true);
      //设置标题
      setTitle("CZY's small calculator");
      //设置关闭按钮行为
      setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
      //可见性设定，一定放在最后
      setVisible(true);
  	}
  	//以上内容也可以不写在构造函数中，而是通过访问对象来设置。
  }
  ```

- 布局：默认的布局管理器是BorderLayout

### 5.3JPanel

- 不能独立的存在，必须添加到其他容器内部
- 允许各种嵌套，跟JFrame用法差不多

### 5.4 布局管理器

#### 5.4.1 FlowLayout

- 默认将组件居中的建放在容器的一行中

- new FlowLayout(FlowLayout.xxx) xxx为左，中，右中的一个

- 不强行设定组件的大小，允许组建拥有自己的尺寸

  new FlowLayout(FlowLayout.RIGHT,20,40) ;

#### 5.4.2 BorderLayout

- 顶层容器的默认布局管理器
- 分为东南西北中五个区域，每个区域可以加入一个组件
- 每个组件通过add加入指定区域 add(new JPannel，BorderLayout.SOUTH);

#### 5.4.3 GridLayout布局管理器

- 网格式布局管理器
- GridLayout(rows,cols)
- 网格的宽度和高度均相同，从左往右依次填充

#### 5.4.4 CardLayout

- 卡片式布局管理器
- 需要有操作后才会显示下一个






绝大多数的Swing组件类都以J 开

### 5.1 框架(frame)old

顶层窗口（没有包含在其他窗口中的窗口）称为框架（frame）

```java
package hehe;

import javax.swing.*;
import java.awt.*;

public class SizedFrameTest
{
    public static void main(String[] args)
    {
        //事件分配线程，必须有
        EventQueue.invokeLater(() ->
        {
            var frame = new SizedFrame();
            frame.setTitle("SizedFrame");//标题
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);//关闭动作
            frame.setVisible(true);//是否显示
            
        });
    }
}

class SizedFrame extends JFrame
{
    public SizedFrame()
    {
    //获取屏幕的尺寸
        Toolkit kit = Toolkit.getDefaultToolkit();
        Dimension screenSize = kit.getScreenSize();
        int screenHeight = screenSize.height;
        int screenWidth = screenSize.width;
	//设置框架的尺寸
        setSize(screenWidth , screenHeight );
        setLocationByPlatform(true);


    }
}

```

框架属性：通过get或set方法

```java
public String getTitle();
public void setTitle(String title);
//当类型为boolean时，获取方法用is开头
```

### 5.2组件(component)old

- 不需要自己调用paintComponent方法，事件处理器会自动调用
- 如果需要强行刷新屏幕需要调用repaint方法

```java
package hehe;

import javax.swing.*;
import java.awt.*;

public class NotHelloWorld
{
    public static  void main( String [] args)
    {
        EventQueue.invokeLater(()->
        {
            var frame=new NotHelloWorldFrame();
            frame.setTitle("Hello world");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            frame.setVisible(true);
        });
    }
}

class NotHelloWorldFrame extends JFrame
{
    public NotHelloWorldFrame()
    {
        Toolkit kit = Toolkit.getDefaultToolkit();
        Dimension screenSize = kit.getScreenSize();
        int screenHeight = screenSize.height;
        int screenWidth = screenSize.width;

        setSize(screenWidth/2 , screenHeight/2 );
        setLocationByPlatform(true);
        //toBack();
        add(new NotHelloWorldComponent());//在框架中调用组件
        pack();//调整窗口大小
    }
}

class NotHelloWorldComponent extends JComponent
{
    public static final int MESSAGE_X=75;
    public static final int MESSAGE_Y=75;
    private static final int DEFAULT_WIDTH=300;
    private static final int DEFAULT_HEIGHT=200;
	//绘制组件
    public void paintComponent(Graphics g)//Graphics包含一个进行绘制的组件
    {
        g.drawString("Hello,world",MESSAGE_X,MESSAGE_Y);
    }

    public Dimension getPreferredSize(){//告诉用户这个组件多大
        return new Dimension(DEFAULT_WIDTH,DEFAULT_HEIGHT);
    }
}
```



### 5.3 处理2D图形（Rectangle2D）old

有一个float，还有一个double

float更省空间，但注意float f=1.2;是错误的，因为1.2为double类型，应改为float f=1.2F#

```java
package hehe;
//p442(425)
import java.awt.*;
import java.awt.geom.*;
import javax.swing.*;

public class DrawTest
{
    public static void main(String[] args)
    {
        EventQueue.invokeLater(() ->
        {
            JFrame frame = new DrawFrame();
            frame.setTitle("DrawTest");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            frame.setVisible(true);
        });
    }
}

/**
 * A frame that contains a panel with drawings
 */
class DrawFrame extends JFrame
{
    public DrawFrame()
    {
        add(new DrawComponent());
        pack();
    }
}

/**
 * A component that displays rectangles and ellipses.
 */
class DrawComponent extends JComponent
{
    private static final int DEFAULT_WIDTH = 400;
    private static final int DEFAULT_HEIGHT = 400;

    public void paintComponent(Graphics g)
    {
        Graphics2D g2 = (Graphics2D) g;//Graphics2D是Graphics的子类

        // draw a rectangle

        double leftX = 100;
        double topY = 100;
        double width = 200;
        double height = 150;

        Rectangle2D rect = new Rectangle2D.Double(leftX, topY, width, height);//创建图形的对象
        g2.draw(rect);//绘图

        // draw the enclosed ellipse

        Ellipse2D ellipse = new Ellipse2D.Double();
        ellipse.setFrame(rect);
        g2.draw(ellipse);

        // draw a diagonal line

        g2.draw(new Line2D.Double(leftX, topY, leftX + width, topY + height));

        // draw a circle with the same center

        double centerX = rect.getCenterX();
        double centerY = rect.getCenterY();
        double radius = 150;

        Ellipse2D circle = new Ellipse2D.Double();
        circle.setFrameFromCenter(centerX, centerY, centerX + radius, centerY + radius);
        g2.draw(circle);
    }

    public Dimension getPreferredSize() { return new Dimension(DEFAULT_WIDTH, DEFAULT_HEIGHT); }
}

```



### 5.4事件处理

```java
package button;

import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

/**
 * A frame with a button panel
 */
public class ButtonFrame extends JFrame
{
   private JPanel buttonPanel;
   private static final int DEFAULT_WIDTH = 300;
   private static final int DEFAULT_HEIGHT = 200;

   public ButtonFrame()
   {
      setSize(DEFAULT_WIDTH, DEFAULT_HEIGHT);

      // 创建按钮
      JButton yellowButton = new JButton("Yellow");
      JButton blueButton = new JButton("Blue");
      JButton redButton = new JButton("Red");
      JButton exitButton =new JButton("exit");
      //创建面板
      buttonPanel = new JPanel();

      // 将按钮添加到面板
      buttonPanel.add(yellowButton);
      buttonPanel.add(blueButton);
      buttonPanel.add(redButton);
      buttonPanel.add(exitButton);

      // 将面板添加到窗口
      add(buttonPanel);

      // 创建按钮动作
      ColorAction yellowAction = new ColorAction(Color.YELLOW);
      ColorAction blueAction = new ColorAction(Color.BLUE);
      ColorAction redAction = new ColorAction(Color.RED);

      //将动作与按钮链接起来
      yellowButton.addActionListener(yellowAction);
      blueButton.addActionListener(blueAction);
      redButton.addActionListener(redAction);
      //对于只有一个动作的监听器可以使用lambda表达式
      exitButton.addActionListener(event->System.exit(0));
   }

   /**
    * An action listener that sets the panel's background color.
    */
   private class ColorAction implements ActionListener
   {
      private Color backgroundColor;

      public ColorAction(Color c)
      {
         backgroundColor = c;
      }

      public void actionPerformed(ActionEvent event)//行为
      {
         buttonPanel.setBackground(backgroundColor);
      }
   }

   public static void main(String[] args) {
      EventQueue.invokeLater(() -> {
         JFrame frame = new ButtonFrame();
         frame.setTitle("ButtonTest");
         frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
         frame.setVisible(true);
      });
   }
}
```





## 6.流

### 6.1标准输入输出流

- System.in 标准输入，主要通过read方法接受键盘数据
- System.out 标准输出，通过print和println方法向控制台输出数据
- System.err 向控制台输出错误信息
- 可以通过set函数进行重定向

### 6.2文件数据流

- FileInputStream 打开一个输入文件。如果指定的文件不存在产生FileNotFoundException异常

- FIleOutputStream 打开一个输出文件，如果不存在创建一个新文件

- 如果读写或者生成新文件时候发生错误，则会产生IOException异常

  ```java
  import java.io.FileInputStream;
  import java.io.FileNotFoundException;
  import java.io.FileOutputStream;
  import java.io.IOException;
  
  public class FileStream
  {
      public static void main(String[] args)
      {
          String filename=new String("D:\\A personal date\\GitHub\\Java_learning\\孟凡超\\流\\src\\FileStream.java");
  
          try
          {
              FileInputStream fis = new FileInputStream(filename);//输入流
              FileOutputStream fos=new FileOutputStream("test.txt");//会覆盖源文件
              int c;//读入的承载体
              int i = 0;
              while ((c = fis.read()) != -1)//不到文件末尾
              {
                  i++;
                  System.out.print((char)c);
                  fos.write(c);
              }
              System.out.println();
              System.out.println("len"+i);
              //关闭文件
              fis.close();
              fos.close();
  
          }
          catch (FileNotFoundException e)
          {
              System.err.println("发生异常："+e);
          }
          catch (IOException e)
          {
              System.err.println("发生异常："+e);
              e.printStackTrace();//是打印异常的堆栈信息，指明错误原因
          }
      }
  }
  
  ```

  #### 6.3 过滤器数据流
  
  ##### 6.3.1 缓冲区数据流
  
  - 增加了缓冲区，减少了访问硬盘的次数，提高了效率
  
  - BufferedInputStream 和BufferedOutputStream，数据以块为单位先进入缓冲区，其后的读写操作作用于缓冲区。
  
  - 在关闭一个缓冲区之前，应该先用flush()方法，强制输出缓冲区剩余数据
  
    ```java	
    static public void test2() throws IOException
      {
            try{
                FileInputStream in=new FileInputStream("test.txt");
                FileOutputStream out=new FileOutputStream("file2.txt");
                InputStream bin=new BufferedInputStream(in);//创建
                OutputStream bout=new BufferedOutputStream(out);
                int c;
                while((c=bin.read())!=-1)
                {
                    bout.write(c);
                }
                bout.flush();
                in.close();
                out.close();
                bin.close();
                bout.close();
            } catch (IOException e)
            {
    
                e.printStackTrace();
            }
    
        }
    ```
  
    

	##### 6.3.2 数据数据流

- 文件流和缓冲区流的处理对象是字节或者字节数组，但数据数据流可以实现对文件不同数据类型的读写。

- byte readByte(); //读取一个字节
  long readLong(); //读取一个长型值
  double readDouble(); //读取一个双精度浮点值
  boolean readBoolean(); //读取一个布尔值
  String readUTF(); //读取一个UTF字符串
  int readInt(); //读取一个int型值
  float readFloat(); //读取一个单精度浮点值
  short readShort(); //读取一个短整型值
  char readChar(); //读取一个字符
  
- 写入把read改为write即可



## 7、多线程

### 7.0 基础知识

#### 7.0.1进程与线程
- 进程一般是对操作系统而言的。不同进程的代码、内部数据和状态都是完全独立的。

- 线程一般是对某程序而言的。不同的线程共享同一块内存空间和同一组系统资源，有可能相互影响。

- 从逻辑的观点来看，多线程意味着一个程序的多行语句同时执行，但是多线程并不等于多次启动一个程序，操作系统也不会把每个线程当作独立的进程来对待。

  

#### 7.0.2 并发与并行

- 并发是逻辑上的同时发生，并行是物理上的同时发生。
- 并发(concurrency)是指在某一段时间内，从宏观上多个程序在同时运行，但在微观上多个程序之间是串行的。
- 并行(parallelism)指两个或两个以上的任务同时运行，无论从宏观上看，还是从微观上看，任务都是同时运行的。

#### 7.0.3Java线程的结构

- 虚拟CPU，封装在java.lang.Thread中，它控制着整个线程的运行。
- 执行的代码，传递给Thread类，由Thread类控制顺序执行。
- 处理的数据，传递给Thread类，是在代码执行过程中所要处理的数据。

#### 7.0.4 线程的状态

通过Thread类来实现的。

- 新建(new)
  当一个线程的实例被创建，即使用new关键字和Thread类或其子类创建一个线程对象后，此时该线程处于new状态。处于new状态的线程有自己的内存空间，但该线程并没有运行，此时线程还不是活着的(not alive)。

- 就绪状态(runnable)
  通过调用线程实例的start()方法来启动线程使线程进入就绪状态。处于就绪状态的线程已经具备了运行条件，但还没有被分配到CPU即不一定会被立即执行，此时处于线程就绪队列，等待系统为其分配CPU，等待状态并不是执行状态，此时线程是活着的(alive)。
  
- 运行状态(running)
  一旦获取CPU(被JVM选中)，线程就进入运行状态，线程的run()方法才开始被执行。在运行状态的线程执行自己的run()方法中的操作，直到调用其他的方法而终止、或者等待某种资源而阻塞、或者完成任务而死亡。如果在给定的时间片内没有执行结束，就会被系统给换下来回到线程的等待状态；此时线程是活着的(alive)。
  
- 阻塞状态(blocked)
  通过调用join()、sleep()、wait()或者资源被暂用使线程处于阻塞状态。处于阻塞状态的线程仍然是活着的(alive) 。
  
- 死亡状态(dead)
  当一个线程的run()方法运行完毕或被中断或被异常退出，该线程到达死亡(dead)状态。此时可能仍然存在一个该Thread的实例对象，当该Thread已经不可能在被作为一个可被独立执行的线程对待了。
  一旦某一线程进入dead状态，他就再也不能进入一个独立线程的生命周期了。对于一个处于Dead状态的线程调用start()方法，会出现一个运行期(runtime exception)的异常。处于dead状态的线程不是活着的(not alive)。
  
  确定线程的状态，可以使用getState()方法

#### 7.0.5 线程分类

- 普通线程：在Java程序中，若还有非Demon线程，则整个程序不会结束
- 守护线程：如果普通线程结束了，守护线程自动终止 setDaemon(true)

### 7.1线程的创建

#### 7.1.1 继承Thread类

- 如果将一个类定义为Thread的子类，那么这个类就可以用来表示线程。
- 定义一个线程类，它继承类Thread并重写其中的方法run()，这时在初始化这个类的实例时，目标对象target可以为null，表示这个实例本身具有线程体。
- 由于Java只支持单继承，用这种方法定义的类不能再继承其他类。

#### 7.1.2 实现Runnable接口

- Runnable是Java中用以实现线程的接口，任何实现线程功能的类都必须实现该接口。前面所用到的Thread类就是因为实现了Runnable接口，所以它的子类才相应具有线程功能。
- Runnable接口中只定义了一个方法就是run()方法，也就是线程体。用Runnable接口实现多线程时，也必须实现run()方法，但此时常用Thread类的构造方法来创建线程对象。



```java
public class CreateThread {

    public static void main(String[] args) {
        Thread1 thread1 = new Thread1();
        //声明一个Thread1对象，这个Thread1类继承自Thread类的

        Thread thread2 = new Thread(new Thread2());
        //传递一个匿名对象作为参数

        thread1.start();
        thread2.start();
        //启动线程
    }
}

class Thread1 extends Thread {
    @Override
    public void run() {
        //在run()方法中放入线程要完成的工作

        //这里我们把两个线程各自的工作设置为打印100次信息
        for (int i = 0; i < 100; ++i) {
            System.out.println("Hello! This is " + i);
        }

        //在这个循环结束后，线程便会自动结束
    }
}

class Thread2 implements Runnable {
    //与Thread1不同，如果当一个线程已经继承了另一个类时，就建议你通过实现Runnable接口来构造

    @Override
    public void run() {
        for (int i = 0; i < 100; ++i) {
            System.out.println("Thanks. There is " + i);
        }
    }
}
```

当然，也可以使用lambda表达式或者匿名类

new Thread(()->{}).start;



#### 7.1.3 Thread类的主要方法

- start();  //启动线程

- run(); //用来定义线程对象被调度之后执行的操作，用户必须重写run()方法

- yield(); //强制终止线程执行

- isAlive(); //测试当前线程是否在活动

- sleep(int millsecond); //使线程休眠一段时间，时间长短由参数所决定

  ```java
  try
  {
      Thread.sleep( int millsecond);
  }
  catch(InterruptedException e)
  {
     	e.printStackTrace();
  }
  ```

  

- void wait(); //使线程处于等待状态

### 7.2 线程的调度

- 时间片轮转调度策略
- 抢占式调度策略（java采用）

#### 7.2.1 java线程调度的优先级策略

- 优先级高的先执行，优先级低的后执行。
- 多线程系统会自动为每个线程分配一个优先级，缺省时，继承其父类的优先级。
- 任务紧急的线程，其优先级较高。
- 同优先级的线程按“先进先出”的原则。

#### 7.2.2 优先级相关的静态量

MAX_PRIORITY：最大优先级，值为10。
MIN_PRIORITY：最小优先级，值为1。
NORM_PRIORITY：默认优先级，值为5。

#### 7.2.3与优先级有关的方法

void setPriority(int newPriority)：重置线程优先级。
int : getPriority()：获得当前线程的优先级。
static void yield()：使当前线程放弃执行权。

#### 7.2.3 线程的调度

- 调用sleep()方法，使线程休眠一段时间。

- 调用yield()方法，可以给其他同等优先级的线程一个运行机会。

- join方法
  在某些情况下，需要让某一个线程等待另一个线程执行结束后再开始执行该线程，可以使用线程类的join()方法来实现上述功能。**当调用某个线程类对象实例的join()方法后，将会等待该线程类对象执行结束**。
  
  ```java
  package 线程的控制;
  
  public class JoinDemo
  {
      static int sum = 0;
  
      public static void main(String[] args) throws InterruptedException
      {
          int[] arr = new int[10];
          Thread producer = new Thread(new Producer(arr));
          producer.start();
          Thread worker = new Thread(new Worker(arr, producer));
          worker.start();
          Thread printTask = new Thread(new PrintTask(worker));
          printTask.start();
          printTask.join();
          int sum1 = 0;
          for (var value : arr)
          {
              sum1 += value;
          }
          if (sum == sum1)
          {
              System.out.println("pass");
          }
          else
          {
              System.out.println("false");
          }
      }
  
  
  }
  
  class Producer implements Runnable
  {
      int[] arr;
  
      public Producer(int[] arr)
      {
          this.arr = arr;
      }
  
      @Override
      public void run()
      {
          System.out.println("初始化。。。");
          for (int i = 0; i < arr.length; i++)
          {
              arr[i] = (int) (Math.random() * 100);
              System.out.println(arr[i]);
          }
      }
  
  }
  
  class Worker implements Runnable
  {
      int[] arr;
      Thread thread;
  
      public Worker(int[] arr, Thread thread)
      {
          this.arr = arr;
          this.thread = thread;
      }
  
      @Override
      public void run()
      {
          try
          {
              thread.join();//让producter先运行
          } catch (InterruptedException e)
          {
              e.printStackTrace();
          }
          System.out.println("开始计算...");
          int sum = 0;
          for (var value : arr)
          {
              sum += value;
          }
          JoinDemo.sum = sum;
      }
  }
  
  class PrintTask implements Runnable
  {
      Thread thread;
  
      public PrintTask(Thread thread)
      {
          this.thread = thread;
      }
  
      @Override
      public void run()
      {
          try
          {
              thread.join();//让worker先执行
              
          } catch (InterruptedException e)
          {
              e.printStackTrace();
          }
          System.out.println("sum=" + JoinDemo.sum);
      }
  
  }
  ```

- 结束线程：从run()方法的结尾处返回时，自动消亡并且不能被再执行

- 中断线程：使用interrupt方法可以请求中断线程执行

  通常在run中用isInterrupted方法判断是否被中断

  ```java
  package 线程的控制;
  
  public class InterruptDemo
  {
      public static void main(String [] args)
      {
          Thread thread=new LeapYearPrinter();
          thread.start();
          try
          {
              Thread.sleep(5);
          } catch (InterruptedException e)//必须有
          {
              e.printStackTrace();
          }
          thread.interrupt();
      }
  }
  
  class LeapYearPrinter extends Thread
  {
      public void run()
      {
          int year=2000;
          System.out.println("闰年包括");
          while(true)
          {
              if(year%4==0 && year%100!=0 || year%400==0)
              {
                  System.out.println(year);
              }
              if(isInterrupted())
              {
                  System.out.println("线程被中断");
                  return;
              }
              year++;
          }
      }
  }
  ```

### 7.3 同步

线程执行的时候有不确定性。同时运行的线程需要共享数据，就必须考虑其他线程的状态与行为，这个时候需要实现同步。

- 互斥锁：每个对象对应一个monitor，上面有一个互斥锁，用来确保任何一个时刻只有一个线程来访问该对象
- 关键字**synchronized**用来与对象的互斥锁联系
- 用法：
  - 对某个代码片段：synchronized(对象){ do something}
  - 对某个方法
    - 放到方法声名中
    - public synchroized ...{do something}，相当于synchronized(this)
- wait（）方法是把调用wait的线程加到对象的锁里面
- notify（）或notifyAll（）可以让等待的一个或者所有线程进入就绪状态
- wait和notify放在synchronized里面。

```java
public class ThreadA {
    public static void main(String[] args){
        ThreadB b = new ThreadB();
        b.start();
 
        synchronized(b){//同步块
            try{
                System.out.println("Waiting for b to complete...");
                b.wait();//把主线程加入到b的等待集合中，暂停了主方法的运行
            }catch(InterruptedException e){
                e.printStackTrace();
            }
 
            System.out.println("Total is: " + b.total);
        }
    }
}
 
class ThreadB extends Thread{
    int total;
    @Override
    public void run(){
        synchronized(this){
            for(int i=0; i<100 ; i++){
                total += i;
            }
            notify();
        }
    }
}
```



## 附录A 一些需要特别注意的小可爱

- java中默认整型常量为int'型，浮点数为double型，若想为长整型需要加L，若想为单精度浮点型加F
- 



1C

2A

3

4C默认int，long型要加l

5B

6C

7C static,静态成员或方法，final定义常量，方法前不能被重写，类前不能被继承

8

9D，定义数组是数组的引用，长度应该放在new上

10B

11B，父类引用可以指向子类，子类不能指向父类

12待定

13C，异常转移throws，异常处理try catch

14A，

15D

16B，外部流入计算机是输入流（cpu和内存），其他都是外部设备

17B

18B

19D

20B



static为类共享

看loop在哪

先调用子类的父类的构造方法，看传入的是啥，父类的构造方法调用子类的重写方法